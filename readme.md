# Детектирования+валидации пачек по QR-кодам + извещение сервера о них

## Очень краткое описание
Непрерывная обработка видео конвейера с детектированием проходящей продукции и чтением с неё QR-кодов.

## Как подготовить и запустить

### Руками
Нужно подготовить виртуальное окружение с **python3.9+**, установить туда зависимости из `requirements.txt` и, 
находясь в окружении, запускать `run_with_1_camera.py`

### Скриптом
На ubuntu18+ подготовку можно выполнить следующим интерактивным скриптом
```bash
./prepare_and_install.sh
```

А запускать можно так
```bash
# активируем виртуальное окружение (достаточно сделать 1 раз за сессию)
. venv/bin/activate
# запускаем программу
python3 run_with_1_camera.py
```

### Конфиг
После первого запуска должен автоматически появиться файл `config.yml`.

Содержимое там обильно снабжено комментариями и выглядит примерно так:
```yaml
# Видео
video_path: "path/to/video/folder/49112-video.mp4"
video_sizer: 0.4
video_show: True

# Логирование
log_file: "logs/tracking.log"
log_level: "DEBUG"
log_format: "<green>{time:YYYY-MM-DD HH:mm:ss.SSS!UTC} UTC+00:00</> | \
             <level>{level: <8}</> | \
             <yellow>PID={process:07d}</> | \
             <cyan>{name}:{function}:{line}</> - <level>{message}</>"

# Сетевые устройства (неявно используются в некоторых конфигурациях)
devices:
    # бэкенд
    backend:
        # ip или домен бэкенда
        domain: localhost
        # таймаут для всех запросов бэкенду
        timeout_sec: 2

    # шторка для сброса пачек
    shutter:
        ...
```

Прочитайте и настройте его под свой случай.

## Что есть? (Фичи)

### Логгирование
Здесь используется loguru для логирования, ротации и сжатия логов.
loguru корректно работает при записи логов из разных потоков, в
случае мультипроцессной записи в один лог достаточно добавить `enqueue=True` в настройки logger'а.

### Конфигурация
Через конфиг можно настроить работу приложения.
Инъекция зависимостей (DI) позволяет менять реализации того или иного компонента без необходимости лезть в код.

Например, можно поменять детектирование простым фильтром цвета на нейросеть, изменив пару строчек конфига.
Аналогично не вызывает проблем поменять адрес сервера, которому необходимо отправлять запросы.

### Оптимальная отправка сетевых запросов
Сетевых запросы (IO-Bound) отправляются асинхронно без блокировки всей программы.
При этом влияние на непрерывную обработку видео (CPU-Bound) сведено к минимуму.

Для этого здесь используется `asyncio.eventloop`, работающий в параллельном потоке.

(В качестве альтернативы можно было использовать `requests`-запросы в отдельных потоках, но при большом кол-ве 
одновременных запросов это бы приводило к частым переключениям контекста и снижению производительности)

### Многопоточная обработка видео
Кадры в `processing.py` распараллеливаются на несколько потоков, 
что позволяет увеличить скорость обработки данных на тяжёлых операциях.

## Структура проекта
```
.
│ # главный (корневой) модуль проекта
├── app
│   ├── __init__.py
│   │
│   │  # взаимозаменяемые группы компонентов
│   │  # (используются при DI-инъекциях)
│   ├── components
│   │   ├── __init__.py
│   │   │
│   │   │  # различные сетевые устройства (бэкенд, шторка сброса, сенсор и т.п)
│   │   │  # используются другими компонентами для реализации сетевых взаимодействий
│   │   ├── network_sources
│   │   │   ├── __init__.py
│   │   │   └── _sources.py
│   │   │
│   │   │  # объекты, отвечающие за получение актуальных данных от бэкенда
│   │   │  # (режим работы и ожидаемое кол-во QR-кодов) 
│   │   ├── accessors
│   │   │   ├── __init__.py
│   │   │   └── _accessors.py
│   │   │
│   │   │  # детекторы пачек по изображениям
│   │   │  # (есть исключение для детектора через snmp-запросы к сенсору)
│   │   ├── detectors
│   │   │   ├── __init__.py
│   │   │   ├── _detectors.py
│   │   │   └── _methods.py
│   │   │
│   │   │  # объекты, отвечающие за оповещение нужных сетевых устройств
│   │   │  # (бэкенд, шторка сброса)
│   │   ├── notifiers
│   │   │   ├── __init__.py
│   │   │   └── _notifiers.py
│   │   │
│   │   │  # валидаторы кодов, считанных камерой
│   │   └── validators
│   │       ├── __init__.py
│   │       └── _validators.py
│   │
│   │  # DI-инъекции
│   │  # (тут данные из конфига превращаются в аргументы компонентов)
│   ├── di_containers.py
│   │
│   │  # удобные функции для обработки изображений
│   ├── image_utils.py
│   │
│   │ # главная функция видеообработки
│   ├── processing.py
│   │
│   │ # подготовка всех компонентов и начало обработки
│   └── main.py
│
│ # Файл, который вы сейчас читаете. Содержит описание проекта
├── readme.md
│
├── .gitignore
│
│ # Сторонние зависимости проекта
├── requirements.txt
│
│ # Конфиг "по умолчанию". Копируется, если не найден конфиг пользователя.
├── sample_config.yaml
│
│ # Конфиг с настройками пользователя (находится в .gitignore)
├── config.yaml
│
│ # Логи пользователя (находятся в .gitignore)
└── logs
    ├── ...
    └── ...
```

## Как это поддерживать

### DI-инъекции и конфигурация

Для внедрения зависимостей тут используется библиотека `dependency_injector`.

Чтобы новые добавленные вами классы можно было менять прямо из конфига
необходимо в файле `di_containers.py` добавить возможность выбора вашего класса 
и перенести из конфига все параметры, которые ожидает ваш класс в конструкторе.

Можно посмотреть в `di_containers.py`, как это уже реализовано 
для классов из `pack_trackers.py` и `pack_detectors.py`, посмотреть примеры 
в репозитории [dependency_injector](https://github.com/ets-labs/python-dependency-injector/)
или изучить [какой-нибудь гайд](
https://medium.com/@rmogylatov/dependency-injector-python-dependency-injection-framework-eeb9f5c6db8b).

### Многопоточная обработка

TODO: добавить комментарии про правильное распараллеливание 
с удалением логики и глобальных переменных из `process_frame`.
